// Code generated by mockery v2.53.3. DO NOT EDIT.

package build

import mock "github.com/stretchr/testify/mock"

// MockTargetBlueprint is an autogenerated mock type for the TargetBlueprint type
type MockTargetBlueprint[T Component, E Component, F interface{}] struct {
	mock.Mock
}

type MockTargetBlueprint_Expecter[T Component, E Component, F interface{}] struct {
	mock *mock.Mock
}

func (_m *MockTargetBlueprint[T, E, F]) EXPECT() *MockTargetBlueprint_Expecter[T, E, F] {
	return &MockTargetBlueprint_Expecter[T, E, F]{mock: &_m.Mock}
}

// Artifacts provides a mock function with no fields
func (_m *MockTargetBlueprint[T, E, F]) Artifacts() []E {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Artifacts")
	}

	var r0 []E
	if rf, ok := ret.Get(0).(func() []E); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]E)
		}
	}

	return r0
}

// MockTargetBlueprint_Artifacts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Artifacts'
type MockTargetBlueprint_Artifacts_Call[T Component, E Component, F interface{}] struct {
	*mock.Call
}

// Artifacts is a helper method to define mock.On call
func (_e *MockTargetBlueprint_Expecter[T, E, F]) Artifacts() *MockTargetBlueprint_Artifacts_Call[T, E, F] {
	return &MockTargetBlueprint_Artifacts_Call[T, E, F]{Call: _e.mock.On("Artifacts")}
}

func (_c *MockTargetBlueprint_Artifacts_Call[T, E, F]) Run(run func()) *MockTargetBlueprint_Artifacts_Call[T, E, F] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockTargetBlueprint_Artifacts_Call[T, E, F]) Return(_a0 []E) *MockTargetBlueprint_Artifacts_Call[T, E, F] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTargetBlueprint_Artifacts_Call[T, E, F]) RunAndReturn(run func() []E) *MockTargetBlueprint_Artifacts_Call[T, E, F] {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function with no fields
func (_m *MockTargetBlueprint[T, E, F]) Data() F {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 F
	if rf, ok := ret.Get(0).(func() F); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(F)
		}
	}

	return r0
}

// MockTargetBlueprint_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type MockTargetBlueprint_Data_Call[T Component, E Component, F interface{}] struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
func (_e *MockTargetBlueprint_Expecter[T, E, F]) Data() *MockTargetBlueprint_Data_Call[T, E, F] {
	return &MockTargetBlueprint_Data_Call[T, E, F]{Call: _e.mock.On("Data")}
}

func (_c *MockTargetBlueprint_Data_Call[T, E, F]) Run(run func()) *MockTargetBlueprint_Data_Call[T, E, F] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockTargetBlueprint_Data_Call[T, E, F]) Return(_a0 F) *MockTargetBlueprint_Data_Call[T, E, F] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTargetBlueprint_Data_Call[T, E, F]) RunAndReturn(run func() F) *MockTargetBlueprint_Data_Call[T, E, F] {
	_c.Call.Return(run)
	return _c
}

// Dependencies provides a mock function with no fields
func (_m *MockTargetBlueprint[T, E, F]) Dependencies() []T {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Dependencies")
	}

	var r0 []T
	if rf, ok := ret.Get(0).(func() []T); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]T)
		}
	}

	return r0
}

// MockTargetBlueprint_Dependencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dependencies'
type MockTargetBlueprint_Dependencies_Call[T Component, E Component, F interface{}] struct {
	*mock.Call
}

// Dependencies is a helper method to define mock.On call
func (_e *MockTargetBlueprint_Expecter[T, E, F]) Dependencies() *MockTargetBlueprint_Dependencies_Call[T, E, F] {
	return &MockTargetBlueprint_Dependencies_Call[T, E, F]{Call: _e.mock.On("Dependencies")}
}

func (_c *MockTargetBlueprint_Dependencies_Call[T, E, F]) Run(run func()) *MockTargetBlueprint_Dependencies_Call[T, E, F] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockTargetBlueprint_Dependencies_Call[T, E, F]) Return(_a0 []T) *MockTargetBlueprint_Dependencies_Call[T, E, F] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTargetBlueprint_Dependencies_Call[T, E, F]) RunAndReturn(run func() []T) *MockTargetBlueprint_Dependencies_Call[T, E, F] {
	_c.Call.Return(run)
	return _c
}

// Env provides a mock function with no fields
func (_m *MockTargetBlueprint[T, E, F]) Env() BlueprintEnv {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Env")
	}

	var r0 BlueprintEnv
	if rf, ok := ret.Get(0).(func() BlueprintEnv); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(BlueprintEnv)
	}

	return r0
}

// MockTargetBlueprint_Env_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Env'
type MockTargetBlueprint_Env_Call[T Component, E Component, F interface{}] struct {
	*mock.Call
}

// Env is a helper method to define mock.On call
func (_e *MockTargetBlueprint_Expecter[T, E, F]) Env() *MockTargetBlueprint_Env_Call[T, E, F] {
	return &MockTargetBlueprint_Env_Call[T, E, F]{Call: _e.mock.On("Env")}
}

func (_c *MockTargetBlueprint_Env_Call[T, E, F]) Run(run func()) *MockTargetBlueprint_Env_Call[T, E, F] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockTargetBlueprint_Env_Call[T, E, F]) Return(_a0 BlueprintEnv) *MockTargetBlueprint_Env_Call[T, E, F] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTargetBlueprint_Env_Call[T, E, F]) RunAndReturn(run func() BlueprintEnv) *MockTargetBlueprint_Env_Call[T, E, F] {
	_c.Call.Return(run)
	return _c
}

// NewMockTargetBlueprint creates a new instance of MockTargetBlueprint. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTargetBlueprint[T Component, E Component, F interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTargetBlueprint[T, E, F] {
	mock := &MockTargetBlueprint[T, E, F]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
